const express = require('express');
const path = require('path');
const { DefaultAzureCredential } = require('@azure/identity');
const { SecretClient } = require('@azure/keyvault-secrets');
const fetch = require('node-fetch');
const app = express();
const PORT = process.env.PORT || 3000;

/* safe env reads */
// read env vars into constants right away (no later reassignment)
const KEY_VAULT_NAME = process.env.KEY_VAULT_NAME || null;
const TTN_SECRET_NAME = process.env.TTN_SECRET_NAME || 'editions-app-key-first';
const TTN_APP_ID = process.env.TTN_APP_ID || 'IDpcb-test-1';
const TTN_BASE_URL = `https://${TTN_APP_ID}.data.thethingsnetwork.org`;

/* global guards & logging */
process.on('unhandledRejection', (err) => {
    console.error('Unhandled rejection:', err && err.stack ? err.stack : err);
});
process.on('uncaughtException', (err) => {
    console.error('Uncaught exception:', err && err.stack ? err.stack : err);
    // Don't process.exit(1) here so Azure/iisnode can capture logs; choose your strategy.
});

/* optional Key Vault client (initialized on demand) */
let secretClient = null;
let credential = null;

function initKeyVaultClientIfNeeded() {
    if (!KEY_VAULT_NAME) return false;
    if (secretClient) return true;
    try {
        credential = new DefaultAzureCredential();
        const vaultUrl = `https://${KEY_VAULT_NAME}.vault.azure.net`;
        secretClient = new SecretClient(vaultUrl, credential);
        console.log('KeyVault client initialized for vault:', KEY_VAULT_NAME);
        return true;
    } catch (err) {
        console.error('Failed to initialize KeyVault client:', err);
        secretClient = null;
        return false;
    }
}

/* In-memory cache for secret */
let cachedSecretValue = null;
let cachedAt = 0;
const SECRET_CACHE_MS = 60 * 1000;

async function getAppSecret() {
    // If vault is not configured, try a fallback env (useful for local testing)
    if (!KEY_VAULT_NAME) {
        if (process.env.TTN_SECRET_FALLBACK) {
            return process.env.TTN_SECRET_FALLBACK;
        }
        throw new Error('KEY_VAULT_NAME not set and no TTN_SECRET_FALLBACK provided');
    }

    if (!initKeyVaultClientIfNeeded()) {
        throw new Error('KeyVault client not initialized');
    }

    if (cachedSecretValue && (Date.now() - cachedAt) < SECRET_CACHE_MS) return cachedSecretValue;

    try {
        const secretResp = await secretClient.getSecret(TTN_SECRET_NAME);
        cachedSecretValue = secretResp.value;
        cachedAt = Date.now();
        return cachedSecretValue;
    } catch (err) {
        console.error('Error reading secret from KeyVault:', err && err.message ? err.message : err);
        throw err;
    }
}

/* Views (EJS) + static assets */
// Configure EJS view engine to use your public/view folder
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'public', 'view')); // points to public/view

// Serve static assets (CSS/JS/images) from public — keep this so your EJS can load /css, /js, etc.
app.use(express.static(path.join(__dirname, 'public')));

// Views and static assets
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'public', 'view'));
app.use(express.static(path.join(__dirname, 'public')));

/* Render index.ejs at root */
app.get('/', (req, res) => {
    try {
        // renders public/view/index.ejs
        return res.render('index');
    } catch (err) {
        console.error('Error rendering index.ejs:', err && err.stack ? err.stack : err);
        return res.status(500).send('Template render error. Check server logs.');
    }
});

/* API route (robust error handling + logging) */
app.get('/api/data', async (req, res) => {
    try {
        // for easier debug log the incoming query
        console.log('/api/data request query:', req.query);

        // optionally short-circuit / health check
        if (req.query._health) return res.json({ ok: true, time: new Date().toISOString() });

        // get secret (throws if not available)
        const secret = await getAppSecret();

        // build forwarded URL in a safe manner
        const pathParam = req.query.path || '/api/v2/query/';
        const qs = new URLSearchParams(req.query);
        qs.delete('path');
        qs.delete('_health'); // remove debug
        const url = `${TTN_BASE_URL}${pathParam}${qs.toString() ? '?' + qs.toString() : ''}`;

        console.log('Fetching external URL:', url);
        const resp = await fetch(url, {
            headers: {
                'Accept': 'application/json',
                'Authorization': `key ${secret}`
            },
            method: 'GET'
        });

        const text = await resp.text();
        if (!resp.ok) {
            console.error('External API returned non-OK:', resp.status, text.slice(0, 1000));
            return res.status(resp.status).send(text);
        }

        try {
            const json = JSON.parse(text);
            return res.json(json);
        } catch (err) {
            // not JSON -> return text
            return res.status(200).send(text);
        }
    } catch (err) {
        console.error('Error in /api/data:', err && err.stack ? err.stack : err);
        // 503 indicates dependency (KeyVault / external API) unavailable
        res.status(503).json({ error: 'Service unavailable', details: err.message });
    }
});

/* fallback route for any other requests (optional) */
app.use((req, res, next) => {
    // if client requests html path and static didn't match, show friendly message
    if (req.accepts('ejs')) {
        return res.status(404).send('Not found. Check that public/index.ejs exists.');
    }
    next();
});

/* error middleware */
app.use((err, req, res, next) => {
    console.error('Express error middleware:', err && err.stack ? err.stack : err);
    res.status(500).json({ error: 'Internal Server Error', details: err.message });
});

/* start server */
app.listen(PORT, () => {
    console.log(`Server listening on port ${PORT} (NODE_ENV=${process.env.NODE_ENV})`);
    if (!KEY_VAULT_NAME) {
        console.warn('KEY_VAULT_NAME not set — /api/data will return 503 unless TTN_SECRET_FALLBACK is provided.');
    }
});